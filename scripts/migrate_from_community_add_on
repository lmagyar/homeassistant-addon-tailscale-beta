#!/usr/bin/env bashio

################################################################################
# Parameters
################################################################################

declare from="a0d7b954_tailscale" # community
declare from_version="0.26.1"

declare to="09716aab_tailscale" # forked
declare to_repository="https://github.com/lmagyar/homeassistant-addon-tailscale"

declare from_defaults=$(jq -rcM <<"EOFROMDEFAULTS"
  {
    "accept_dns": true,
    "accept_routes": true,
    "advertise_exit_node": true,
    "advertise_connector": true,
    "advertise_routes": ["local_subnets"],
    "log_level": "info",
    "login_server": "https://controlplane.tailscale.com",
    "share_homeassistant": "disabled",
    "share_on_port": "443",
    "snat_subnet_routes": true,
    "stateful_filtering": false,
    "tags": [],
    "taildrop": true,
    "userspace_networking": true
  }
EOFROMDEFAULTS
)

# rename tags to advertise_tags
declare from_patch='.advertise_tags = .tags | del(.tags)'



################################################################################
################################################################################

# This is curently missing from bashio

# ------------------------------------------------------------------------------
# Returns or sets whether or not ingress_panel is enabled for this add-on.
#
# Arguments:
#   $1 Add-on slug (optional, default: self)
#   $2 Set current ingress_panel state (Optional)
# ------------------------------------------------------------------------------
function bashio::addon.ingress_panel() {
    local slug=${1:-'self'}
    local ingress_panel=${2:-}

    bashio::log.trace "${FUNCNAME[0]}" "$@"

    if bashio::var.has_value "${ingress_panel}"; then
        ingress_panel=$(bashio::var.json ingress_panel "^${ingress_panel}")
        bashio::api.supervisor POST "/addons/${slug}/options" "${ingress_panel}"
        bashio::cache.flush_all
    else
        bashio::addons \
            "${slug}" \
            "addons.${slug}.ingress_panel" \
            '.ingress_panel // false'
    fi
}

################################################################################

function wait_for_backup() {
  local uuid=${1}
  local job_info

  echo -ne "Waiting for the backup job to finish..."
  while true
  do
    if ! job_info=$(ha jobs info --raw-json \
      | jq -ercM ".data.jobs[] | select(.uuid == \"${uuid}\") | {done, errors}")
    then
      echo -e "\nERROR: Can't get backup job info\n"
      exit 1
    elif bashio::var.equals $(bashio::jq "${job_info}" ".done") "true"; then
      if bashio::var.equals $(bashio::jq "${job_info}" ".errors | length") "0"; then
        echo -e "\nBackup has finished\n"
        break
      else
        echo -e "\nERROR: Backup job has failed\n"
        for error in $(bashio::jq "${job_info}" ".errors"); do
          echo "${error}"
        done
        exit 1
      fi
    else
      echo -ne "."
      sleep 1
    fi
  done
}

################################################################################
# Initialization
################################################################################

declare backup_job

bashio::cache.flush_all

echo

################################################################################
# Check "from" add-on and it's version
################################################################################

declare from_info=$(ha ad info "${from}" --raw-json)
if ! bashio::var.equals $(bashio::jq "${from_info}" ".result") "ok"; then
  echo -e "ERROR: Add-on ${from} is unknown\n"
  exit 1
fi

declare from_name=$(bashio::jq "${from_info}" ".data.name")
declare from_installed=$(bashio::jq "${from_info}" ".data.installed")
if bashio::var.false "${from_installed}"; then
  echo -e "ERROR: Add-on ${from} (${from_name}) is not installed\n"
  exit 1
fi

declare from_current_version=$(bashio::jq "${from_info}" ".data.version")
declare from_state=$(bashio::jq "${from_info}" ".data.state")
if ! bashio::var.equals "${from_current_version}" "${from_version}"; then
  echo -e "ERROR: Add-on ${from} (${from_name}) version ${from_current_version} is different from the expected ${from_version}\n"
  exit 1
fi

################################################################################
# Ensure "to" repository is added
################################################################################

if ha store --raw-json \
  | jq -e ".data.repositories[] | select(.slug == \"${to:0:8}\")" > /dev/null
then
  echo -e "Add-on repository ${to_repository} of add-on ${to} is already installed\n"
else
  echo -e "Installing add-on repository ${to_repository} of add-on ${to}..."
  ha store add "${to_repository}"
  echo
fi

################################################################################
# Install or backup "to" add-on
################################################################################

declare to_info=$(ha ad info "${to}" --raw-json)
declare to_name=$(bashio::jq "${to_info}" ".data.name")

declare to_installed=$(bashio::jq "${to_info}" ".data.installed")
if bashio::var.false "${to_installed}"; then
  echo -e "Installing add-on ${to} (${to_name})..."
  ha addons install "${to}"
  echo
else
  declare to_state=$(bashio::jq "${to_info}" ".data.state")
  if bashio::var.equals "${to_state}" "started" \
    || bashio::var.equals "${to_state}" "startup"
  then
    echo -e "Stopping add-on ${to} (${to_name})..."
    ha addons stop "${to}"
    echo
  fi
  echo -e "Backing up add-on ${to} (${to_name})..."
  if ! backup_job=$(ha backups new --addons "${to}" --name "Add-on ${to_name}" --raw-json \
    | jq -ercM '.data.job_id')
  then
    echo -e "ERROR starting backup\n"
    exit 1
  else
    wait_for_backup "${backup_job}"
  fi
fi

################################################################################
# Stop, disable, backup "from" add-on
################################################################################

if bashio::var.equals "${from_state}" "started" \
  || bashio::var.equals "${from_state}" "startup"
then
  echo -e "Stopping add-on ${from} (${from_name})..."
  ha addons stop "${from}"
  echo
fi

declare from_boot=$(bashio::addon.boot "${from}")
if ! bashio::var.equals "${from_boot}" "manual"; then
  echo -e "Disabling start on boot for add-on ${from} (${from_name})..."
  bashio::addon.boot "${from}" "manual"
fi

declare from_watchdog=$(bashio::addon.watchdog "${from}")
if bashio::var.true "${from_watchdog}"; then
  echo -e "Disabling watchdog for add-on ${from} (${from_name})..."
  bashio::addon.watchdog "${from}" "false"
fi

declare from_auto_update=$(bashio::addon.auto_update "${from}")
if bashio::var.true "${from_auto_update}"; then
  echo -e "Disabling auto update for add-on ${from} (${from_name})..."
  bashio::addon.auto_update "${from}" "false"
fi

declare from_ingress_panel=$(bashio::addon.ingress_panel "${from}")
if bashio::var.true "${from_ingress_panel}"; then
  echo -e "Removing from the sidebar the add-on ${from} (${from_name})..."
  bashio::addon.ingress_panel "${from}" "false"
fi

echo -e "Backing up add-on ${from} (${from_name})..."
if ! backup_job=$(ha backups new --addons "${from}" --name "Add-on ${from_name}" --raw-json \
  | jq -ercM '.data.job_id')
then
  echo -e "ERROR starting backup\n"
  exit 1
else
  wait_for_backup "${backup_job}"
fi

################################################################################
# Copy config inside supervisor's container
################################################################################

docker exec -i `docker ps -q -f name="^hassio_supervisor$"` /bin/bash -c 'cat > /tmp/cfg_copy_args' <<EODOCKERARGS

set -o errexit  # Exit script when a command exits with non-zero status
set -o errtrace # Exit on error inside any functions or sub-shells
set -o nounset  # Exit script on use of an undefined variable
set -o pipefail # Return exit status of the last command in the pipe that failed

################################################################################
## Export parameters
################################################################################

declare from='${from}'
declare from_name='${from_name}'
declare to='${to}'
declare to_name='${to_name}'
declare from_defaults='${from_defaults}'
declare from_patch='${from_patch}'

EODOCKERARGS

docker exec -i `docker ps -q -f name="^hassio_supervisor$"` /bin/bash <<"EODOCKER"

set -o errexit  # Exit script when a command exits with non-zero status
set -o errtrace # Exit on error inside any functions or sub-shells
set -o nounset  # Exit script on use of an undefined variable
set -o pipefail # Return exit status of the last command in the pipe that failed

################################################################################
## Import parameters
################################################################################

source /tmp/cfg_copy_args

################################################################################
## Prepare pyrasite
################################################################################

echo -e "Installing gdb in Supervisor's container...\n"

apk add --upgrade --no-cache --quiet --no-progress gdb

echo -e "Installing Pyrasite in Supervisor's container...\n"

if ! pip freeze | grep -Eq '^pyrasite-ng=='; then
  pip install --root-user-action ignore --no-input --quiet pyrasite-ng
fi

mkdir -p /tmp/pyrasite-fake-bin
cat > /tmp/pyrasite-fake-bin/ps <<"EOPS"
#!/usr/bin/env bash
if [[ "$#" == "5" && "${1:-}" == "--no-heading" && "${2:-}" == "-o" && "${3:-}" == "cmd=" && "${4:-}" == "-p" ]]; then
  /bin/ps -o pid=,comm= | grep -E "^\s*$5\s+" | awk '{ print $2 }'
else
  /bin/ps "$@"
fi
EOPS
chmod 755 /tmp/pyrasite-fake-bin/ps

################################################################################
## Copy configuration
################################################################################

echo -e "Copying configuration from ${from} (${from_name}) to ${to} (${to_name})...\n"

function merge_options() {
  local -n from=${1}
  local -n to=${2}
  jq -srcM 'map(to_entries) | flatten | group_by(.key) | map({key: .[0].key, value: .[0].value}) | from_entries' <<< "${from}${to}"
}

declare from_options=$(jq -rcM ".user.\"${from}\".options" /data/addons.json)
declare to_options=$(jq -rcM ".user.\"${to}\".options // \"\"" /data/addons.json)
declare merged="${from_options}"

# merge default options
if [[ -n "${from_defaults}" ]]; then
  merged=$(merge_options merged from_defaults)
fi

# execute patch
if [[ -n "${from_patch}" ]]; then
  merged=$(jq -rcM "${from_patch}" <<< "${merged}")
fi

# merge from and to options
if [[ -n "${to_options}" ]]; then
  merged=$(merge_options merged to_options)
fi

# replace config with merged values
cp -f /data/addons.json /tmp/old_addons.json
jq --argjson merged "${merged}" ".user.\"${to}\".options = \$merged" /data/addons.json > /tmp/new_addons.json
cp -f /tmp/new_addons.json /data/addons.json

# copy data
mkdir -p /data/addons/data/$to
cp -a /data/addons/data/$from/. /data/addons/data/$to

################################################################################
## Reread configuration
################################################################################

echo -e "Rereading modified add-ons configuration by Supervisor..."

cat > /tmp/reread_addons.py <<"EOPY"
def wait(coro):
  event = threading.Event()
  task = coresys.create_task(coro)
  task.add_done_callback(lambda _: event.set())
  event.wait()
  return task.result()
wait(coresys._addons.data.read_data())
print("Supervisor has reread the modified add-ons configuration data")
EOPY

PATH=/tmp/pyrasite-fake-bin:$PATH pyrasite $(/bin/ps | grep -E "python3\s-m\ssupervisor" | awk '{ print $1 }') --output localterm --ipc-timeout 60 /tmp/reread_addons.py

EODOCKER

################################################################################
# Backup original addons.json
################################################################################

declare addons_backup_filename="/share/addons_$(date "+%Y%m%d_%H%M%S").json"
echo -e "Copying original addons.json from Supervisor to ${addons_backup_filename}..."
docker cp `docker ps -q -f name="^hassio_supervisor$"`:/tmp/old_addons.json "${addons_backup_filename}"
echo
echo -e "NOTICE: If everything goes well, you can safely delete the ${addons_backup_filename} file later"
echo -e "To restore it, use: docker cp ${addons_backup_filename} \`docker ps -q -f name=\"^hassio_supervisor$\"\`:/data/addons.json\n"

################################################################################
# Enable, start "to" add-on
################################################################################

declare to_boot=$(bashio::addon.boot "${to}")
if ! bashio::var.equals "${from_boot}" "${to_boot}"; then
  if bashio::var.equals "${from_boot}" "manual"; then
    echo -e "Disabling start on boot for add-on ${to} (${to_name})..."
  else
    echo -e "Enabling start on boot for add-on ${to} (${to_name})..."
  fi
  bashio::addon.boot "${to}" "${from_boot}"
fi

declare to_watchdog=$(bashio::addon.watchdog "${to}")
if ! bashio::var.equals "${from_watchdog}" "${to_watchdog}"; then
  if bashio::var.false "${from_watchdog}"; then
    echo -e "Disabling watchdog for add-on ${to} (${to_name})..."
  else
    echo -e "Enabling watchdog for add-on ${to} (${to_name})..."
  fi
  bashio::addon.watchdog "${to}" "${from_watchdog}"
fi

declare to_auto_update=$(bashio::addon.auto_update "${to}")
if ! bashio::var.equals "${from_auto_update}" "${to_auto_update}"; then
  if bashio::var.false "${from_auto_update}"; then
    echo -e "Disabling auto update for add-on ${to} (${to_name})..."
  else
    echo -e "Enabling auto update for add-on ${to} (${to_name})..."
  fi
  bashio::addon.auto_update "${to}" "${from_auto_update}"
fi

declare to_ingress_panel=$(bashio::addon.ingress_panel "${to}")
if ! bashio::var.equals "${from_ingress_panel}" "${to_ingress_panel}"; then
  if bashio::var.false "${from_ingress_panel}"; then
    echo -e "Removing from the sidebar the add-on ${to} (${to_name})..."
  else
    echo -e "Adding to the sidebar the add-on ${to} (${to_name})..."
  fi
  bashio::addon.ingress_panel "${to}" "${from_ingress_panel}"
fi

if bashio::var.equals "${from_state}" "started"; then
  echo -e "Starting add-on ${to} (${to_name})..."
  # ha addons start "${to}" - this times out
  bashio::addon.start "${to}" > /dev/null
  echo -e "Command completed successfully.\n"
fi

echo "****************************************************************************************************"
echo
echo "Migration was successful!"
echo
echo "- You can safely delete the ${addons_backup_filename} file now"
echo "- You can safely uninstall the ${from} (${from_name}) add-on now"
echo
echo "IMPORTANT: Do not try to start the original ${from} (${from_name}) add-on"
echo "when the new ${to} (${to_name}) add-on is running,"
echo "because they have identical internal states!!!"
echo
echo "IMPORTANT: Refresh Home Assistant's UI (web page) to reflect the changes done by this script!"
echo
echo "****************************************************************************************************"
echo
