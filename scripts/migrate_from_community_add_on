#!/usr/bin/env bashio

################################################################################
# Parameters
################################################################################

declare from="a0d7b954_tailscale" # community
declare from_version="0.26.1"

declare to="09716aab_tailscale" # forked
declare to_repository="https://github.com/lmagyar/homeassistant-addon-tailscale"

declare from_defaults=$(jq -rcM <<"EOFROMDEFAULTS"
  {
    "accept_dns": true,
    "accept_routes": true,
    "advertise_exit_node": true,
    "advertise_connector": true,
    "advertise_routes": ["local_subnets"],
    "log_level": "info",
    "login_server": "https://controlplane.tailscale.com",
    "share_homeassistant": "disabled",
    "share_on_port": "443",
    "snat_subnet_routes": true,
    "stateful_filtering": false,
    "tags": [],
    "taildrop": true,
    "userspace_networking": true
  }
EOFROMDEFAULTS
)

# rename tags to advertise_tags
declare from_patch='.advertise_tags = .tags | del(.tags)'

# addresses to be removed from net config
declare dns_ipv4="100.100.100.100"
declare dns_ipv6="fd7a:115c:a1e0::53"



################################################################################
# Initialization
################################################################################

echo
echo "****************************************************************************************************"
echo
echo "If the migration script fails, fix the problem that caused it to fail, and start the script again!"
echo
echo "The migration script can be run multiple times, you will end up in the same state!"
echo
echo "****************************************************************************************************"
echo

bashio::cache.flush_all

################################################################################
# Function definitions
################################################################################

# This is curently missing from bashio

# ------------------------------------------------------------------------------
# Returns or sets whether or not ingress_panel is enabled for this add-on.
#
# Arguments:
#   $1 Add-on slug (optional, default: self)
#   $2 Set current ingress_panel state (Optional)
# ------------------------------------------------------------------------------
function bashio::addon.ingress_panel() {
    local slug=${1:-'self'}
    local ingress_panel=${2:-}

    bashio::log.trace "${FUNCNAME[0]}" "$@"

    if bashio::var.has_value "${ingress_panel}"; then
        ingress_panel=$(bashio::var.json ingress_panel "^${ingress_panel}")
        bashio::api.supervisor POST "/addons/${slug}/options" "${ingress_panel}"
        bashio::cache.flush_all
    else
        bashio::addons \
            "${slug}" \
            "addons.${slug}.ingress_panel" \
            '.ingress_panel // false'
    fi
}

################################################################################

function wait_for_backup() {
  local uuid=${1}
  local job_info

  echo -ne "Waiting for the backup job to finish..."
  while true
  do
    if ! job_info=$(ha jobs info --raw-json \
      | jq -ercM ".data.jobs[] | select(.uuid == \"${uuid}\") | {done, errors}")
    then
      echo -e "\nERROR: Can't get backup job info\n"
      exit 1
    elif bashio::var.equals $(bashio::jq "${job_info}" ".done") "true"; then
      if bashio::var.equals $(bashio::jq "${job_info}" ".errors | length") "0"; then
        echo -e "\nBackup has finished\n"
        break
      else
        echo -e "\nERROR: Backup job has failed\n"
        for error in $(bashio::jq "${job_info}" ".errors"); do
          echo "${error}"
        done
        exit 1
      fi
    else
      echo -ne "."
      sleep 1
    fi
  done
}

################################################################################
# Check running environment
################################################################################

if ! bashio::var.equals "$(bashio::addons "self" "false" ".slug")" "a0d7b954_ssh"; then
  echo -e "ERROR: You are not running this script within the Advanced SSH & Web Terminal add-on!\n"
  exit 1
fi

if bashio::var.true "$(bashio::addon.protected "self")"; then
  echo -e "ERROR: Protection mode is enabled!\n"
  echo -e "To be able to use this script, you need to disable protection mode on the Advanced SSH & Web Terminal add-on."
  echo -e "Without it, the script is unable to access Docker.\n"
  echo -e "Steps:"
  echo -e " - Go to the Supervisor Panel."
  echo -e " - Click on the Advanced SSH & Web Terminal add-on."
  echo -e " - Set the 'Protection mode' switch to off."
  echo -e " - Restart the add-on.\n"
  exit 1
fi

################################################################################
# Check "from" add-on and it's version
################################################################################

declare from_info=$(ha ad info "${from}" --raw-json)
if ! bashio::var.equals $(bashio::jq "${from_info}" ".result") "ok"; then
  echo -e "ERROR: Add-on ${from} is unknown\n"
  exit 1
fi

declare from_name=$(bashio::jq "${from_info}" ".data.name")
declare from_installed=$(bashio::jq "${from_info}" ".data.installed")
if bashio::var.false "${from_installed}"; then
  echo -e "ERROR: Add-on ${from} (${from_name}) is not installed\n"
  exit 1
fi

declare from_current_version=$(bashio::jq "${from_info}" ".data.version")
declare from_state=$(bashio::jq "${from_info}" ".data.state")
if ! bashio::var.equals "${from_current_version}" "${from_version}"; then
  echo -e "ERROR: Add-on ${from} (${from_name}) version ${from_current_version} is different from the expected ${from_version}\n"
  exit 1
fi

################################################################################
# Ensure "to" repository is added
################################################################################

if ha store --raw-json \
  | jq -e ".data.repositories[] | select(.slug == \"${to:0:8}\")" > /dev/null
then
  echo -e "Add-on repository ${to_repository} of add-on ${to} is already installed\n"
else
  echo -e "Installing add-on repository ${to_repository} of add-on ${to}..."
  ha store add "${to_repository}"
  echo
fi

################################################################################
# Install or backup "to" add-on
################################################################################

declare to_info=$(ha ad info "${to}" --raw-json)
declare to_name=$(bashio::jq "${to_info}" ".data.name")

declare to_installed=$(bashio::jq "${to_info}" ".data.installed")
if bashio::var.false "${to_installed}"; then
  echo -e "Installing add-on ${to} (${to_name})..."
  ha addons install "${to}"
  echo
else
  declare to_state=$(bashio::jq "${to_info}" ".data.state")
  if bashio::var.equals "${to_state}" "started" \
    || bashio::var.equals "${to_state}" "startup"
  then
    echo -e "Stopping add-on ${to} (${to_name})..."
    ha addons stop "${to}"
    echo
  fi
  echo -e "Backing up add-on ${to} (${to_name})..."
  if ! backup_job=$(ha backups new --addons "${to}" --name "Add-on ${to_name}" --raw-json \
    | jq -ercM '.data.job_id')
  then
    echo -e "ERROR starting backup\n"
    exit 1
  else
    wait_for_backup "${backup_job}"
  fi
fi

################################################################################
# Stop, disable, backup "from" add-on
################################################################################

if bashio::var.equals "${from_state}" "started" \
  || bashio::var.equals "${from_state}" "startup"
then
  echo -e "Stopping add-on ${from} (${from_name})..."
  ha addons stop "${from}"
  echo
fi

declare from_boot=$(bashio::addon.boot "${from}")
if ! bashio::var.equals "${from_boot}" "manual"; then
  echo -e "Disabling start on boot for add-on ${from} (${from_name})..."
  bashio::addon.boot "${from}" "manual"
fi

declare from_watchdog=$(bashio::addon.watchdog "${from}")
if bashio::var.true "${from_watchdog}"; then
  echo -e "Disabling watchdog for add-on ${from} (${from_name})..."
  bashio::addon.watchdog "${from}" "false"
fi

declare from_auto_update=$(bashio::addon.auto_update "${from}")
if bashio::var.true "${from_auto_update}"; then
  echo -e "Disabling auto update for add-on ${from} (${from_name})..."
  bashio::addon.auto_update "${from}" "false"
fi

declare from_ingress_panel=$(bashio::addon.ingress_panel "${from}")
if bashio::var.true "${from_ingress_panel}"; then
  echo -e "Removing from the sidebar the add-on ${from} (${from_name})..."
  bashio::addon.ingress_panel "${from}" "false"
fi

echo -e "Backing up add-on ${from} (${from_name})..."
if ! backup_job=$(ha backups new --addons "${from}" --name "Add-on ${from_name}" --raw-json \
  | jq -ercM '.data.job_id')
then
  echo -e "ERROR starting backup\n"
  exit 1
else
  wait_for_backup "${backup_job}"
fi

################################################################################
# Copy config inside supervisor's container
################################################################################

docker exec -i `docker ps -q -f name="^hassio_supervisor$"` /bin/bash -c 'cat > /tmp/cfg_copy_args' <<EODOCKERARGS

set -o errexit  # Exit script when a command exits with non-zero status
set -o errtrace # Exit on error inside any functions or sub-shells
set -o nounset  # Exit script on use of an undefined variable
set -o pipefail # Return exit status of the last command in the pipe that failed

################################################################################
## Export parameters
################################################################################

declare from='${from}'
declare from_name='${from_name}'
declare to='${to}'
declare to_name='${to_name}'
declare from_defaults='${from_defaults}'
declare from_patch='${from_patch}'

EODOCKERARGS

docker exec -i `docker ps -q -f name="^hassio_supervisor$"` /bin/bash <<"EODOCKER"

set -o errexit  # Exit script when a command exits with non-zero status
set -o errtrace # Exit on error inside any functions or sub-shells
set -o nounset  # Exit script on use of an undefined variable
set -o pipefail # Return exit status of the last command in the pipe that failed

################################################################################
## Import parameters
################################################################################

source /tmp/cfg_copy_args

################################################################################
## Prepare pyrasite
################################################################################

echo -e "Installing gdb in Supervisor's container..."

apk add --no-cache --quiet --no-progress gdb
echo

echo -e "Installing Pyrasite in Supervisor's container..."

if ! pip freeze | grep -Eq '^pyrasite-ng=='; then
  pip install --root-user-action ignore --no-input --quiet pyrasite-ng==2.0.3
fi

mkdir -p /tmp/pyrasite-fake-bin
cat > /tmp/pyrasite-fake-bin/ps <<"EOPS"
#!/usr/bin/env bash
if [[ "$#" == "5" && "${1:-}" == "--no-heading" && "${2:-}" == "-o" && "${3:-}" == "cmd=" && "${4:-}" == "-p" ]]; then
  /bin/ps -o pid=,comm= | grep -E "^\s*$5\s+" | awk '{ print $2 }'
else
  /bin/ps "$@"
fi
EOPS
chmod 755 /tmp/pyrasite-fake-bin/ps

echo

################################################################################
## Copy configuration
################################################################################

echo -e "Copying configuration from ${from} (${from_name}) to ${to} (${to_name})..."

function merge_options() {
  local -n from=${1}
  local -n to=${2}
  jq -srcM 'map(to_entries) | flatten | group_by(.key) | map({key: .[0].key, value: .[0].value}) | from_entries' <<< "${from}${to}"
}

declare from_options=$(jq -rcM ".user.\"${from}\".options" /data/addons.json)
declare to_options=$(jq -rcM ".user.\"${to}\".options // \"\"" /data/addons.json)
declare merged="${from_options}"

# merge default options
if [[ -n "${from_defaults}" ]]; then
  merged=$(merge_options merged from_defaults)
fi

# execute patch
if [[ -n "${from_patch}" ]]; then
  merged=$(jq -rcM "${from_patch}" <<< "${merged}")
fi

# merge from and to options
if [[ -n "${to_options}" ]]; then
  merged=$(merge_options merged to_options)
fi

# replace config with merged values
cp -f /data/addons.json /tmp/old_addons.json
jq --argjson merged "${merged}" ".user.\"${to}\".options = \$merged" /data/addons.json > /tmp/new_addons.json
cp -f /tmp/new_addons.json /data/addons.json

# copy data
mkdir -p /data/addons/data/$to
cp -a /data/addons/data/$from/. /data/addons/data/$to

echo

################################################################################
## Reread configuration
################################################################################

echo -e "Rereading modified add-ons configuration by Supervisor..."

cat > /tmp/reread_addons.py <<"EOPY"
def wait(coro):
  event = threading.Event()
  task = coresys.create_task(coro)
  task.add_done_callback(lambda _: event.set())
  event.wait()
  return task.result()
wait(coresys._addons.data.read_data())
print("Supervisor has reread the modified add-ons configuration data")
EOPY

PATH=/tmp/pyrasite-fake-bin:$PATH pyrasite $(/bin/ps | grep -E "python3\s-m\ssupervisor" | awk '{ print $1 }') --output localterm --ipc-timeout 60 /tmp/reread_addons.py

################################################################################
## Remove pyrasite
################################################################################

echo -e "Uninstalling Pyrasite in Supervisor's container..."

rm -rf /tmp/pyrasite-fake-bin
pip uninstall --root-user-action ignore --yes --quiet pyrasite-ng urwid wcwidth
echo

echo -e "Uninstalling gdb in Supervisor's container..."

apk del --no-cache --quiet --no-progress gdb
echo

EODOCKER

################################################################################
# Backup original addons.json
################################################################################

declare addons_backup_filename="/share/addons_$(date "+%Y%m%d_%H%M%S").json"
echo -e "Copying original addons.json from Supervisor to ${addons_backup_filename}..."
docker cp `docker ps -q -f name="^hassio_supervisor$"`:/tmp/old_addons.json "${addons_backup_filename}"
echo
echo -e "NOTICE: If everything goes well, you can safely delete the ${addons_backup_filename} file later"
echo -e "To restore it, use: docker cp ${addons_backup_filename} \`docker ps -q -f name=\"^hassio_supervisor$\"\`:/data/addons.json\n"

################################################################################
# Check network config
################################################################################

if bashio::var.has_value "${dns_ipv4}"; then
  # select interfaces where it is used (ipv4)
  for interface in $(ha net info --raw-json \
    | jq -rcM ".data.interfaces[] | select(.ipv4.nameservers | index(\"${dns_ipv4}\")) | .interface")
  do
    echo -e "NOTICE: Configuring add-on provided DNS addresses for network interfaces is bad practice and causes issues"
    echo -e "NOTICE: Please check your configuration based on the ${to} (${to_name}) add-on's documentation"
    if ha net info "${interface}" --raw-json \
      | jq -ercM '.data.ipv4.method != "static"' > /dev/null
    then
      echo -e "WARNING: Interface ${interface} IPv4 configuration is not static, please remove manually the DNS server ${dns_ipv4} from ${interface} configuration"
    else
      echo -e "Removing DNS server ${dns_ipv4} from interface ${interface} configuration..."
      # ha net update "${interface}" --ipv4-nameserver ... is broken, have to send the whole config
      bashio::api.supervisor POST "/network/interface/${interface}/update" "$(ha net info "${interface}" --raw-json \
        | jq -ercM ".data.ipv4 | {address, nameservers, gateway} | del(.nameservers[.nameservers | index(\"${dns_ipv4}\")]) | {ipv4: .}")" > /dev/null
    fi
    echo
  done
fi

if bashio::var.has_value "${dns_ipv6}"; then
  # select interfaces where it is used (ipv6)
  for interface in $(ha net info --raw-json \
    | jq -rcM ".data.interfaces[] | select(.ipv6.nameservers | index(\"${dns_ipv6}\")) | .interface")
  do
    echo -e "NOTICE: Configuring add-on provided DNS addresses for network interfaces is bad practice and causes issues"
    echo -e "NOTICE: Please check your configuration based on the ${to} (${to_name}) add-on's documentation"
    if ha net info "${interface}" --raw-json \
      | jq -ercM '.data.ipv6.method != "static"' > /dev/null
    then
      echo -e "WARNING: Interface ${interface} IPv6 configuration is not static, please remove manually the DNS server ${dns_ipv6} from ${interface} configuration"
    else
      echo -e "Removing DNS server ${dns_ipv6} from interface ${interface} configuration..."
      # ha net update "${interface}" --ipv6-nameserver ... is broken, have to send the whole config
      bashio::api.supervisor POST "/network/interface/${interface}/update" "$(ha net info "${interface}" --raw-json \
        | jq -ercM ".data.ipv6 | {address, nameservers, gateway} | del(.nameservers[.nameservers | index(\"${dns_ipv6}\")]) | {ipv6: .}")" > /dev/null
    fi
    echo
  done
fi

bashio::cache.flush_all

################################################################################
# Enable, start "to" add-on
################################################################################

declare to_boot=$(bashio::addon.boot "${to}")
if ! bashio::var.equals "${from_boot}" "${to_boot}"; then
  if bashio::var.equals "${from_boot}" "manual"; then
    echo -e "Disabling start on boot for add-on ${to} (${to_name})..."
  else
    echo -e "Enabling start on boot for add-on ${to} (${to_name})..."
  fi
  bashio::addon.boot "${to}" "${from_boot}"
fi

declare to_watchdog=$(bashio::addon.watchdog "${to}")
if ! bashio::var.equals "${from_watchdog}" "${to_watchdog}"; then
  if bashio::var.false "${from_watchdog}"; then
    echo -e "Disabling watchdog for add-on ${to} (${to_name})..."
  else
    echo -e "Enabling watchdog for add-on ${to} (${to_name})..."
  fi
  bashio::addon.watchdog "${to}" "${from_watchdog}"
fi

declare to_auto_update=$(bashio::addon.auto_update "${to}")
if ! bashio::var.equals "${from_auto_update}" "${to_auto_update}"; then
  if bashio::var.false "${from_auto_update}"; then
    echo -e "Disabling auto update for add-on ${to} (${to_name})..."
  else
    echo -e "Enabling auto update for add-on ${to} (${to_name})..."
  fi
  bashio::addon.auto_update "${to}" "${from_auto_update}"
fi

declare to_ingress_panel=$(bashio::addon.ingress_panel "${to}")
if ! bashio::var.equals "${from_ingress_panel}" "${to_ingress_panel}"; then
  if bashio::var.false "${from_ingress_panel}"; then
    echo -e "Removing from the sidebar the add-on ${to} (${to_name})..."
  else
    echo -e "Adding to the sidebar the add-on ${to} (${to_name})..."
  fi
  bashio::addon.ingress_panel "${to}" "${from_ingress_panel}"
fi

if bashio::var.equals "${from_state}" "started"; then
  echo -e "Starting add-on ${to} (${to_name})..."
  # ha addons start "${to}" - this times out
  bashio::addon.start "${to}" > /dev/null
  echo -e "Command completed successfully.\n"
fi

echo "****************************************************************************************************"
echo
echo "Migration was successful!"
echo
echo "- You can safely delete the ${addons_backup_filename} file now"
echo "- You can safely uninstall the ${from} (${from_name}) add-on now"
echo
echo "IMPORTANT: Do not try to start the original ${from} (${from_name}) add-on"
echo "when the new ${to} (${to_name}) add-on is running,"
echo "because they have identical internal states!!!"
echo
echo "IMPORTANT: Refresh Home Assistant's UI (web page) to reflect the changes done by this script!"
echo
echo "****************************************************************************************************"
echo
